\subsection{28. Алгоритм разбора по LR-таблице. Структура стека. Корректность и полнота разбора (на отл).}
\par Пусть у нас есть готовая LR-таблица table и дано слово $w=w_1 \ldots w_n\$$. Создаем стек: изначально записываем в него 0 - номер правила $S' \rightarrow S$, так как оно всегда первое в нашем выводе. Дальше запускаем цикл \begin{enumerate}
    \item Если последний символ на стеке - это номер правила ($i$), то пытаемся дописать на стек следующую букву слова $w_j$: проверяем, если в ячейке $[i, w_j]$ стоит пометка $shift$ (то есть из текущего состояния есть переход по этой букве), то дописываем эту букву на стек, иначе говорим, что слово не лежит в языке.
    \item Берем последние 2 символа со стека: среди них гарантированно одна буква ($c$) и одно число ($k$). Смотрим в ячейку $[k, c]$ \begin{enumerate}
        \item Если там стоит $(shift, to)$, то дописываем на стек $to$ - номер состояния в который надо перейти
        \item Если там стоит $(reduce, rule)$, то находим правило под номером $rule$, удаляем со стека $2 \cdot |rule.right|$ символов (нужно удалить все буквы из этого правила, но на стеке они чередуются с цифрами, поэтому умножаем длину на 2)  и дописать $rule.left$. Если делаем свертку по 0 правилу $S' \rightarrow S$, то есть в этой ячейке стоит Accept, то говорим, что слово лежит в языке.
        \item Если там стоит Error, то слово не лежит в языке
    \end{enumerate}
\end{enumerate}
\par Из алгоритма видно, что на стеке чередуются буквы и числа (в самом начале число)
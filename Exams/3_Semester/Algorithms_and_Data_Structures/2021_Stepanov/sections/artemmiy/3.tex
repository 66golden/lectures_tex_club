\Def Пусть есть строка $s = s_0 s_1 \dots s_{n - 1}$,  тогда $[\pi_0, \pi_1, \dots, \pi_{n-1}]$ — префикс-функция для $s$, где $\pi_i$ — длина максимального собственного суффикса строки $s_0 s_1 \dots s_i$, который совпадает с префиксом той же длины.

\Example $s = ababbabbaaba$, $\pi: [0, 0, 1, 2, 0, 1, 2, 0, 1, 2, 3]$.

\textbf{Применение}. Пусть есть алгоритм, находящий $\pi$ за $O(|s|)$. Вспомним задачу про вхождение шаблона в текст. Рассмотрим строку $pattern \# text$, где $\#$ — разделитель, отличный от всех остальных символов. Тогда если значение префикс-функции равно $|pattern|$, то мы обнаружили вхождение шаблона в текст.

\Note Из-за $\#$ значение $\pi$ не сможет превзойти $|pattern|$.

\textbf{Algorithm.} (Нахождение префикс-функции. Алгоритм Кнута-Морриса-Пратта) 
Последовательно строим массив $\pi$.

1) $\pi_0 = 0$ (База) 

2) (Шаг) Пусть $\pi_0, \dots, \pi_{i-1}$ известны. Найдём $\pi_i$. Заметим, что:

a) $\pi_i \leqslant \pi_{i-1} + 1$ (рассматриваем $s_i$, совпадающий префикс если удлиняется, то не более, чем на $1$ (отностительно предыдущего))

b) Если убрать из супрефикс для $s_0 \dots s_i$ последний символ — получим супрефикс для $s_0 \dots s_{i-1}$

c) второй по длине супрефикс для $s_0 \dots s_{i}$ имеет длину $\pi_{(\pi_{i} - 1)}$ (вычитается 1 т.к. нумерация с 0) (это верно потому что $s_0 \dots s_{\pi_{i} - 1}$ является суффиксом $s_0 \dots s_i$, соответственно второй по длине супрефикс $s_0 \dots s_{i}$ будет максимальным супрефиксом $s_0 \dots s_{\pi_{i} - 1}$). Аналогично доказывается, что третий по длине супрефикс для $s_0 \dots s_{i}$ имеет длину $\pi_{(\pi_{(\pi_{i} - 1)} - 1)}$. И так далее.

Чтобы найти $\pi_{i}$ необходимо найти максимальный по длине супрефикс $s_0 \dots s_{i-1}$, который можно продолжить символом $s_i$. Для этого перебираем максимальный супрефикс $s_0 \dots s_{i-1}$, второй по величине супрефикс, третий, и т.д. пока не получим совпадение $s_i$ и $s_j$. Если пришли к супрефиксу нулевой длиный (и $s_0 \not= s_i$), то супрефикса для $s_0 \dots s_{i}$ не существует. $\pi_i = 0$.

Теперь реализуем:

\begin{lstlisting}
vector<int> p_function(const string& s) {
  int n = s.size();
  vector<int> p(n);
  for (int i = 1; i < n; ++i) {
    int j = p[i-1];
    while (j > 0 && s[j] != s[i]) {
      j = p[j - 1];
    }
    if (s[j] == s[i]) {
      ++j;
    }
    p[i] = j;
  }
  return p;
}
\end{lstlisting}

\Example $s = abacabaab$, $\pi = [0, 0, 1, 0, 1, 2, 3, x]$. Хотим найти значение $x$. $j = 3$ не подходит, супрефикс увеличить не удаётся. Возьмём $j = p[j - 1] = p[2] = 1$, но и тут та же проблема, и далее $j = p[1] = 0$. (тут выходим из while). Но так как $s[j] = s[0]$ равен $s[i]$, то ($j$ увеличивается на 1) $x = 1$.

\textbf{Асимптотика}. Суммарно цикл while работает $O(n)$ времени, так как каждой своей итерацией уменьшает значение $j$ хотя бы на 1. А значение префикс-функции может расти не более, чем на 1. Получается, что если значение префикс функции росло $k$ раз, то оно падало суммарно не более чем на $k$. 

Значит и весь алгоритм работает за $O(n)$ времени, а также $O(n)$ памяти.

Плюс префикс-функции: никакой вероятности, всё точно, детерминировано.

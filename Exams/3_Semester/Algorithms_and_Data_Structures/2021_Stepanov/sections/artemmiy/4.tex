\Def Есть строка $s_0 s_1 \dots s_{n-1}$, значения функции: $z_0, z_1, \dots, z_{n-1}$, каждое значение $z_i$ — наибольшая длина префикса строки $s_i, \dots, s_{n-1}$, который совпадает с префиксом $s_0, \dots, s_{n-1}$ той же длины (Z-блока).

Наивный алгоритм работает за $O(n^2)$, передвигаем два указателя до первого различия.

\textbf{Применение}. Пусть есть алгоритм, находящий $\pi$ за $O(|s|)$. Вспомним задачу про вхождение шаблона в текст. Рассмотрим строку $pattern \# text$, где $\#$ — разделитель, отличный от всех остальных символов. Тогда если значение z-функции равно $|pattern|$, то мы обнаружили вхождение шаблона в текст.

\Def Z-блок — префикс строки $s_i, \dots, s_{n-1}$, совпадающий с префиксом строки $s_0, \dots, s_{n-1}$ той же длины.

\textbf{Algorithm.} (Z-функция) 

$z_0 = 0$. Далее будем хранить Z-блок с самой правой границей. Пусть $z_0, \dots, z_{i-1}$ известны, найдём $z_i$. Пусть $s_l, \dots, s_r$ — тот самый Z-блок ($r = l + z[l] - 1$). Рассмотрим случаи:

1) $i > r$.
Наивным алгоритмом (поочерёдным сравнением значений: вначале $s_0$ и $s_i$. потом $s_1$ и $s_{(i+1)}$ и т.д.) находим ответ.

2) $i \in [l, r]$. Заметим, что если мы сдвинем блок $s_l, \dots, s_r$ на $l$ влево, то получим ту же строку ($s_{0} \dots s_{r-l}$). $z[i-l]$ уже посчитан. Значит $z[i]$ не меньше $min(z_{(i-l)}, r - i + 1)$. Ограничение в $r - i + 1$ нужно для того, чтобы мы не вышли за границу r (за границу $Z$-блока). Далее наивным алгоритмом: поочерёдным сравнением символов, находим $z_i$.

Теперь реализуем:

\begin{lstlisting}
vector<int> z_function(const string& s) {
  int n = s.size();
  vector<int> z(n); //z[0] = n by defition, but nobody cares
  int l = - 1, r  = -1;
  for (int i = 1; i < n; ++i) {
    if (l <= i && i <= r) {
      z[i] = min(z[i-l], r - i + 1);
    }
    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) {
      ++z[i];
    }
    if (i + z[i] - 1 > r) {
      l = i;
      r = i + z[i] - 1;
    }
  }
  return z;
}
\end{lstlisting}

\textbf{Асимптотика}. Заметим, что $while$ работает только в том случае, когда правая граница искомого $Z$-Блока (для текущего $i$) расширяется за пределы $r$. Соответвенно каждая итерация while двигает самую правую границу среди $Z$-блоков. Следовательно, количество итераций $while$ не превысит количество возможных сдвигов вправо, а таковых максимум $O(n)$. 

Значит, и весь алгоритм работает за $O(n)$ времени, а также $O(n)$ памяти.
